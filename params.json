{"name":"Critbit","tagline":"Critbit tree for JRuby","body":"### Critbit Trees\r\n\r\nA crit bit tree, also known as a Binary Patricia\r\nTrie is a trie (https://en.wikipedia.org/wiki/Trie), also called digital tree and sometimes\r\nradix tree or prefix tree (as they\r\ncan be searched by prefixes), is an ordered tree data structure that is used to store a\r\ndynamic set or associative array where the keys are usually strings. Unlike a binary search\r\ntree, no node in the tree stores the key associated with that node; instead, its position\r\nin the tree defines the key with which it is associated. All the descendants of a node have\r\na common prefix of the string associated with that node, and the root is associated with\r\nthe empty string. Values are normally not associated with every node, only with leaves and\r\nsome inner nodes that correspond to keys of interest. For the space-optimized presentation\r\nof prefix tree, see compact prefix tree.\r\n\r\n[The following is from: http://cr.yp.to/critbit.html]\r\n\r\nA crit-bit tree supports the following operations (and more!) at high speed:\r\n\r\n  + See whether a string x is in the tree.\r\n  + Add x to the tree.\r\n  + Remove x from the tree.\r\n  + Find the lexicographically smallest string in the tree larger than x, if there is one.\r\n  + Find all suffixes of x in the tree, i.e., all strings in the tree that have x as a prefix. Of course, this can take a long time if there are many such strings, but each string is found quickly.\r\n  \r\nA crit-bit tree can be used as a high-speed associative array. For example, an array mapping\r\n54 to 1, 19 to 2, 99 to 3, 85 to 4, and 88 to 5 can be stored as a crit-bit tree containing\r\n54=1, 19=2, 99=3, 85=4, and 88=5. The smallest string in the crit-bit tree larger than 85= is\r\n85=4.\r\n\r\nThe standard strategy for many years has been to store searchable data sets as hash tables,\r\nin applications that need exact searches but not lexicographic searches; or as heaps, in\r\napplications that need to search for the minimum; or as AVL trees, red-black trees, etc. in\r\napplications that do not fit the restrictions of hash tables and heaps.\r\n\r\nIn Python, for example, the built-in \"dict\" data type is a hash table. Hash tables don't\r\nprovide fast access to the smallest entry, so there's also a standard \"heapq\" library\r\nproviding heaps. Heaps don't provide fast lookups of other entries, so there are various\r\nadd-on libraries providing AVL trees and so on. A programmer who's happy creating a \"dict\"\r\nwill simply do so, but then another programmer who wants fancier operations on the resulting\r\ndatabase has to do an expensive conversion of the \"dict\" to a fancier data structure.\r\n\r\nI (D. J. Bernstein) have become convinced that this strategy should change. The revised\r\nstrategy is much simpler: there should be one fundamental set-storage type, namely a crit-bit\r\ntree. Here's how a crit-bit tree stacks up against the competition:\r\n\r\nA hash table supports insertion, deletion, and exact searches. A crit-bit tree supports\r\ninsertion, deletion, exact searches, and ordered operations such as finding the minimum.\r\nAnother advantage is that a crit-bit tree guarantees good performance: it doesn't have any\r\ntricky slowdowns for unusual (or malicious) data.\r\n\r\nA heap supports insertion, deletion, and finding the minimum. A crit-bit tree supports\r\ninsertion, deletion, finding the minimum, and exact searches, and general suffix searches.\r\n\r\nGeneral-purpose comparison-based structures such as AVL trees and B-trees support exactly the\r\nsame operations as a crit-bit tree. However, crit-bit trees are faster and simpler, especially\r\nfor variable-length strings. B-trees advertise a memory layout that's friendly to your disk,\r\nbut with less effort one can use a similar \"clustering\" organization for nodes in a crit-bit\r\ntree.\r\n\r\nIf you're designing a programming language, imagine how much happier your programmers will be\r\nif your basic built-in data type allows not just looking up x, but also enumerating the\r\nstrings after x in sorted order. You can't do this with hash tables. You could do it with an\r\nAVL tree, but your operations will be simpler and faster if you use a crit-bit tree.\r\n\r\nCritbit Interface\r\n=================\r\n\r\nThis version of Critbit implements a subset of Ruby's Hash interface and will evolve to\r\nimplement the whole Hash interface.  Besides implementing the Hash interface it also provides\r\nfeatures for searching for keys that have a common prefix.\r\n\r\nHere is an example of using Critbit:\r\n\r\n      crit = Critbit.new\r\n\r\n      # crit is space efficient and stores prefixes only once and can be used to\r\n      # find only strings that match a certain prefix\r\n      items = [\"u\", \"un\", \"unh\", \"uni\", \"unj\", \"unim\", \"unin\", \"unio\",\r\n               \"uninc\", \"unind\", \"unine\", \"unindd\", \"uninde\", \"unindf\",\r\n               \"unindew\", \"unindex\", \"unindey\", \"a\", \"z\"]\r\n\r\n      # add items to the container\r\n      items.each do |item|\r\n        crit[item] = item\r\n      end\r\n\r\n      # Does each for all elements in the container\r\n      crit.each do |key, value|\r\n         p \"Key: crit[key], value: #{value}\"\r\n      end\r\n\r\nPrints:\r\n\r\n\r\n\r\n      # Each can also filter by prefix.  Let's try prefix unin\r\n      pre = [\"unin\", \"uninc\", \"unind\", \"unine\", \"unindd\", \"uninde\", \"unindf\",\r\n             \"unindew\", \"unindex\", \"unindey\"]\r\n      crit.each(\"unin\") do |key, value|\r\n        assert_equal(true, pre.include?(key))\r\n      end\r\n\r\n\r\nCritbit installation and download:\r\n==================================\r\n\r\n  + Install Jruby\r\n  + jruby –S gem install critbit\r\n\r\nCritbit Homepages:\r\n==================\r\n\r\n  + http://rubygems.org/gems/critbit\r\n  + https://github.com/rbotafogo/critbit/wiki\r\n\r\nContributors:\r\n=============\r\n\r\nContributors are welcome.\r\n\r\nCritbit History:\r\n================\r\n\r\n  + 05/04/2013: Version 0.5.0 – Initial release.\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}